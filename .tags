!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	//
$(NAME)	Makefile	/^$(NAME):$/;"	t
*.tcc	.vscode/settings.json	/^		"*.tcc": "cpp",$/;"	s	object:files.associations
0	.vscode/launch.json	/^			{$/;"	o	array:configurations.0.setupCommands
0	.vscode/launch.json	/^		"args": ["8000" , "2"],$/;"	s	array:configurations.0.args
0	.vscode/launch.json	/^	{$/;"	o	array:configurations
1	.vscode/launch.json	/^			{$/;"	o	array:configurations.0.setupCommands
1	.vscode/launch.json	/^		"args": ["8000" , "2"],$/;"	s	array:configurations.0.args
ANGRY	Includes/cuocuo.hpp	/^	ANGRY$/;"	e	enum:e_relation
BG_BLACK	Includes/colours.hpp	/^# define BG_BLACK /;"	d
BG_BLUE	Includes/colours.hpp	/^# define BG_BLUE /;"	d
BG_BRIGHT_BLACK	Includes/colours.hpp	/^# define BG_BRIGHT_BLACK /;"	d
BG_BRIGHT_BLUE	Includes/colours.hpp	/^# define BG_BRIGHT_BLUE /;"	d
BG_BRIGHT_CYAN	Includes/colours.hpp	/^# define BG_BRIGHT_CYAN /;"	d
BG_BRIGHT_GREEN	Includes/colours.hpp	/^# define BG_BRIGHT_GREEN /;"	d
BG_BRIGHT_MAGENTA	Includes/colours.hpp	/^# define BG_BRIGHT_MAGENTA /;"	d
BG_BRIGHT_RED	Includes/colours.hpp	/^# define BG_BRIGHT_RED /;"	d
BG_BRIGHT_WHITE	Includes/colours.hpp	/^# define BG_BRIGHT_WHITE /;"	d
BG_BRIGHT_YELLOW	Includes/colours.hpp	/^# define BG_BRIGHT_YELLOW /;"	d
BG_CYAN	Includes/colours.hpp	/^# define BG_CYAN /;"	d
BG_GREEN	Includes/colours.hpp	/^# define BG_GREEN /;"	d
BG_MAGENTA	Includes/colours.hpp	/^# define BG_MAGENTA /;"	d
BG_RED	Includes/colours.hpp	/^# define BG_RED /;"	d
BG_RESET	Includes/colours.hpp	/^# define BG_RESET /;"	d
BG_WHITE	Includes/colours.hpp	/^# define BG_WHITE /;"	d
BG_YELLOW	Includes/colours.hpp	/^# define BG_YELLOW /;"	d
BLACK	Includes/colours.hpp	/^# define BLACK /;"	d
BLUE	Includes/colours.hpp	/^# define BLUE /;"	d
BOLD	Includes/colours.hpp	/^# define BOLD /;"	d
BRIGHT_BLACK	Includes/colours.hpp	/^# define BRIGHT_BLACK /;"	d
BRIGHT_BLUE	Includes/colours.hpp	/^# define BRIGHT_BLUE /;"	d
BRIGHT_CYAN	Includes/colours.hpp	/^# define BRIGHT_CYAN /;"	d
BRIGHT_GREEN	Includes/colours.hpp	/^# define BRIGHT_GREEN /;"	d
BRIGHT_MAGENTA	Includes/colours.hpp	/^# define BRIGHT_MAGENTA /;"	d
BRIGHT_RED	Includes/colours.hpp	/^# define BRIGHT_RED /;"	d
BRIGHT_WHITE	Includes/colours.hpp	/^# define BRIGHT_WHITE /;"	d
BRIGHT_YELLOW	Includes/colours.hpp	/^# define BRIGHT_YELLOW /;"	d
BUFFER_SIZE	Includes/main.hpp	/^#define BUFFER_SIZE /;"	d
CC	Makefile	/^CC = clang++ -Wall -Wextra -Werror -std=c++98 -g$/;"	m
COLOURS_H	Includes/colours.hpp	/^# define COLOURS_H$/;"	d
CYAN	Includes/colours.hpp	/^# define CYAN /;"	d
Channel	Includes/Channel.hpp	/^		Channel() {}$/;"	f	class:Channel
Channel	Includes/Channel.hpp	/^class Channel$/;"	c
Channel	srcs/Channel.cpp	/^Channel::Channel(Channel const &src)$/;"	f	class:Channel
Channel	srcs/Channel.cpp	/^Channel::Channel(std::string name, Server *server) : m_server(server)$/;"	f	class:Channel
Channel	srcs/Channel.cpp	/^Channel::Channel(std::string name, Server *server, std::map<char ,int> modes) : m_server(server)$/;"	f	class:Channel
Client	Includes/Client.hpp	/^		Client() {}$/;"	f	class:Client
Client	Includes/Client.hpp	/^class Client$/;"	c
Client	srcs/Client.cpp	/^Client::Client(Client const &src)$/;"	f	class:Client
Client	srcs/Client.cpp	/^Client::Client(int clientSocket, struct sockaddr_in clientAddr)$/;"	f	class:Client
ClientException	Includes/server.hpp	/^		class ClientException : public std::exception$/;"	c	class:Server
Coucou	Includes/cuocuo.hpp	/^class Coucou$/;"	c
Coucou	bonus/coucou.cpp	/^Coucou::Coucou()$/;"	f	class:Coucou
GREEN	Includes/colours.hpp	/^# define GREEN /;"	d
HAPPY	Includes/cuocuo.hpp	/^	HAPPY,$/;"	e	enum:e_relation
INC	Makefile	/^INC = -I Includes$/;"	m
MAGENTA	Includes/colours.hpp	/^# define MAGENTA /;"	d
MAIN_HPP	Includes/main.hpp	/^#define MAIN_HPP$/;"	d
MIMode	.vscode/launch.json	/^		"MIMode": "gdb",$/;"	s	object:configurations.0
My Project	Readme.md	/^# My Project$/;"	c
NAME	Makefile	/^NAME = ircserv$/;"	m
NORMAL	Includes/cuocuo.hpp	/^	NORMAL,$/;"	e	enum:e_relation
NumberToString	Includes/main.hpp	/^std::string NumberToString(T Number)$/;"	f	typeref:typename:std::string
OBJS	Makefile	/^OBJS = $(SRCS:.cpp=.o)$/;"	m
PURPLE	Includes/colours.hpp	/^# define PURPLE /;"	d
PollException	Includes/server.hpp	/^		class PollException : public std::exception$/;"	c	class:Server
RED	Includes/colours.hpp	/^# define RED /;"	d
RESET	Includes/colours.hpp	/^# define RESET /;"	d
REVERSED	Includes/colours.hpp	/^# define REVERSED /;"	d
SRC	Makefile	/^SRC = $(SRCS) $(UTILS)$/;"	m
SRCS	Makefile	/^SRCS =	srcs\/main.cpp \\$/;"	m
Server	Includes/server.hpp	/^		Server() {}$/;"	f	class:Server
Server	Includes/server.hpp	/^class Server$/;"	c
Server	srcs/server.cpp	/^Server::Server(char *port, char *psw)$/;"	f	class:Server
TO IMPLEMENT	Readme.md	/^## TO IMPLEMENT$/;"	s
UNDERLINE	Includes/colours.hpp	/^# define UNDERLINE /;"	d
UTILS	Makefile	/^UTILS = utils\/string_utils.cpp$/;"	m
WHITE	Includes/colours.hpp	/^# define WHITE /;"	d
YELLOW	Includes/colours.hpp	/^# define YELLOW /;"	d
accept_connection	srcs/server.cpp	/^void Server::accept_connection()$/;"	f	class:Server	typeref:typename:void
add_ban	Includes/Channel.hpp	/^		void	add_ban(std::string ban) { m_bans.insert(ban); }$/;"	f	class:Channel	typeref:typename:void
add_channel	srcs/server.cpp	/^void	Server::add_channel(std::string name)$/;"	f	class:Server	typeref:typename:void
add_channel	srcs/server.cpp	/^void	Server::add_channel(std::string name, std::map<char, int> modes)$/;"	f	class:Server	typeref:typename:void
add_client	srcs/Channel.cpp	/^void	Channel::add_client(std::string client)$/;"	f	class:Channel	typeref:typename:void
add_invite	Includes/Channel.hpp	/^		void	add_invite(std::string invite) { m_invites.insert(invite);}$/;"	f	class:Channel	typeref:typename:void
add_op	Includes/Channel.hpp	/^		void	add_op(std::string op) { m_ops.insert(op); }$/;"	f	class:Channel	typeref:typename:void
algorithm	.vscode/settings.json	/^		"algorithm": "cpp",$/;"	s	object:files.associations
all	Makefile	/^all: $(NAME)$/;"	t
args	.vscode/launch.json	/^		"args": ["8000" , "2"],$/;"	a	object:configurations.0
array	.vscode/settings.json	/^		"array": "cpp",$/;"	s	object:files.associations
atomic	.vscode/settings.json	/^		"atomic": "cpp",$/;"	s	object:files.associations
away	srcs/Client.cpp	/^bool	Client::away(std::string message)$/;"	f	class:Client	typeref:typename:bool
bind_socket	srcs/server.cpp	/^void Server::bind_socket(void)$/;"	f	class:Server	typeref:typename:void
bit	.vscode/settings.json	/^		"bit": "cpp",$/;"	s	object:files.associations
byte_array_to_hex_string	srcs/Hashing.cpp	/^std::string byte_array_to_hex_string(const unsigned char* byte_array, size_t length)$/;"	f	typeref:typename:std::string
cap	srcs/server.cpp	/^bool Server::cap(int client, std::string message)$/;"	f	class:Server	typeref:typename:bool
cctype	.vscode/settings.json	/^		"cctype": "cpp",$/;"	s	object:files.associations
change_relation	bonus/coucou.cpp	/^void	Coucou::change_relation(Client& client, std::vector<std::string> words, std::string message/;"	f	class:Coucou	typeref:typename:void
check_input	srcs/parse.cpp	/^void	check_input(char *port, char *psw)$/;"	f	typeref:typename:void
cinttypes	.vscode/settings.json	/^		"cinttypes": "cpp"$/;"	s	object:files.associations
clean	Makefile	/^clean:$/;"	t
clientSocketException	Includes/server.hpp	/^		class clientSocketException : public std::exception$/;"	c	class:Server
client_exist	srcs/server.cpp	/^bool	Server::client_exist(const std::string& client) const$/;"	f	class:Server	typeref:typename:bool
clocale	.vscode/settings.json	/^		"clocale": "cpp",$/;"	s	object:files.associations
cmath	.vscode/settings.json	/^		"cmath": "cpp",$/;"	s	object:files.associations
compare	.vscode/settings.json	/^		"compare": "cpp",$/;"	s	object:files.associations
concepts	.vscode/settings.json	/^		"concepts": "cpp",$/;"	s	object:files.associations
configurations	.vscode/launch.json	/^	"configurations": [$/;"	a
create_socket	srcs/server.cpp	/^void Server::create_socket(void)$/;"	f	class:Server	typeref:typename:void
csignal	.vscode/settings.json	/^		"csignal": "cpp",$/;"	s	object:files.associations
cstdarg	.vscode/settings.json	/^		"cstdarg": "cpp",$/;"	s	object:files.associations
cstddef	.vscode/settings.json	/^		"cstddef": "cpp",$/;"	s	object:files.associations
cstdint	.vscode/settings.json	/^		"cstdint": "cpp",$/;"	s	object:files.associations
cstdio	.vscode/settings.json	/^		"cstdio": "cpp",$/;"	s	object:files.associations
cstdlib	.vscode/settings.json	/^		"cstdlib": "cpp",$/;"	s	object:files.associations
cstring	.vscode/settings.json	/^		"cstring": "cpp",$/;"	s	object:files.associations
ctime	.vscode/settings.json	/^		"ctime": "cpp",$/;"	s	object:files.associations
cwchar	.vscode/settings.json	/^		"cwchar": "cpp",$/;"	s	object:files.associations
cwctype	.vscode/settings.json	/^		"cwctype": "cpp",$/;"	s	object:files.associations
cwd	.vscode/launch.json	/^		"cwd": "${workspaceFolder}",$/;"	s	object:configurations.0
deque	.vscode/settings.json	/^		"deque": "cpp",$/;"	s	object:files.associations
description	.vscode/launch.json	/^				"description": "Abilita la riformattazione per gdb",$/;"	s	object:configurations.0.setupCommands.0
description	.vscode/launch.json	/^				"description": "Imposta Versione Disassembly su Intel",$/;"	s	object:configurations.0.setupCommands.1
domain_expansion	bonus/coucou.cpp	/^void	Coucou::domain_expansion(Client& client)$/;"	f	class:Coucou	typeref:typename:void
e_relation	Includes/cuocuo.hpp	/^typedef enum e_relation$/;"	g
environment	.vscode/launch.json	/^		"environment": [],$/;"	a	object:configurations.0
exception	.vscode/settings.json	/^		"exception": "cpp",$/;"	s	object:files.associations
externalConsole	.vscode/launch.json	/^		"externalConsole": false,$/;"	b	object:configurations.0
fclean	Makefile	/^fclean: clean$/;"	t
files.associations	.vscode/settings.json	/^	"files.associations": {$/;"	o
fstream	.vscode/settings.json	/^		"fstream": "cpp",$/;"	s	object:files.associations
functional	.vscode/settings.json	/^		"functional": "cpp",$/;"	s	object:files.associations
generate_salt	srcs/Hashing.cpp	/^std::string generate_salt(size_t length)$/;"	f	typeref:typename:std::string
getTerminalWidth	utils/string_utils.cpp	/^int getTerminalWidth() {$/;"	f	typeref:typename:int
get_away_msg	Includes/Client.hpp	/^		std::string get_away_msg( void ) const { return m_away_msg; }$/;"	f	class:Client	typeref:typename:std::string
get_bans	Includes/Channel.hpp	/^		std::set<std::string>	get_bans() { return m_bans; }$/;"	f	class:Channel	typeref:typename:std::set<std::string>
get_channel	srcs/server.cpp	/^Channel*	Server::get_channel(std::string name)$/;"	f	class:Server	typeref:typename:Channel *
get_clientSocket	Includes/Client.hpp	/^		int			get_clientSocket( void ) const { return m_clientSocket; }$/;"	f	class:Client	typeref:typename:int
get_client_by_nick	srcs/server.cpp	/^Client*		Server::get_client_by_nick(std::string nick)$/;"	f	class:Server	typeref:typename:Client *
get_clients	Includes/Channel.hpp	/^		std::set<std::string>	get_clients() { return m_clients; }$/;"	f	class:Channel	typeref:typename:std::set<std::string>
get_cmds	srcs/server.cpp	/^void Server::get_cmds()$/;"	f	class:Server	typeref:typename:void
get_connected	Includes/Client.hpp	/^		bool		get_connected( void ) const { return m_connected; }$/;"	f	class:Client	typeref:typename:bool
get_hostname	Includes/Client.hpp	/^		std::string get_hostname( void ) const { return m_hostname; }$/;"	f	class:Client	typeref:typename:std::string
get_invites	Includes/Channel.hpp	/^		std::set<std::string>	get_invites() { return m_invites; }$/;"	f	class:Channel	typeref:typename:std::set<std::string>
get_key	Includes/Channel.hpp	/^		std::string	get_key() { return m_key; }$/;"	f	class:Channel	typeref:typename:std::string
get_limit	Includes/Channel.hpp	/^		int	get_limit() { return m_limit; }$/;"	f	class:Channel	typeref:typename:int
get_mode_funcs	Includes/Channel.hpp	/^		std::map<char, void (Channel::*)(Client&, std::string, bool)>	get_mode_funcs() { return m_mode/;"	f	class:Channel	typeref:typename:std::map<char,void (Channel::*)(Client &,std::string,bool)>
get_modes	Includes/Channel.hpp	/^		std::map<char, int>	get_modes() { return m_modes; }$/;"	f	class:Channel	typeref:typename:std::map<char,int>
get_name	Includes/Channel.hpp	/^		std::string	get_name() { return m_name; }$/;"	f	class:Channel	typeref:typename:std::string
get_name	bonus/coucou.cpp	/^std::string Coucou::get_name(Client& client) const$/;"	f	class:Coucou	typeref:typename:std::string
get_nick	Includes/Client.hpp	/^		std::string get_nick( void ) const { return m_nick; }$/;"	f	class:Client	typeref:typename:std::string
get_ops	Includes/Channel.hpp	/^		const std::set<std::string>&	get_ops() const { return m_ops; }$/;"	f	class:Channel	typeref:typename:const std::set<std::string> &
get_realname	Includes/Client.hpp	/^		std::string get_realname( void ) const { return m_realname; }$/;"	f	class:Client	typeref:typename:std::string
get_reg_steps	Includes/Client.hpp	/^		int			get_reg_steps( void ) const { return m_reg_steps; }$/;"	f	class:Client	typeref:typename:int
get_registered	Includes/Client.hpp	/^		bool		get_registered( void ) const { return m_registered; }$/;"	f	class:Client	typeref:typename:bool
get_servername	Includes/Client.hpp	/^		std::string get_servername( void ) const { return m_servername; }$/;"	f	class:Client	typeref:typename:std::string
get_time	utils/string_utils.cpp	/^std::string get_time(void)$/;"	f	typeref:typename:std::string
get_topic	Includes/Channel.hpp	/^		std::string	get_topic() { return m_topic; }$/;"	f	class:Channel	typeref:typename:std::string
get_user	Includes/Client.hpp	/^		std::string get_user( void ) const { return m_user; }$/;"	f	class:Client	typeref:typename:std::string
handle_signal	srcs/main.cpp	/^void	handle_signal(int sig)$/;"	f	typeref:typename:void
hash_password	srcs/Hashing.cpp	/^std::string hash_password(const std::string& password, const std::string& salt)$/;"	f	typeref:typename:std::string
ignoreFailures	.vscode/launch.json	/^				"ignoreFailures": true$/;"	b	object:configurations.0.setupCommands.0
ignoreFailures	.vscode/launch.json	/^				"ignoreFailures": true$/;"	b	object:configurations.0.setupCommands.1
initializer_list	.vscode/settings.json	/^		"initializer_list": "cpp",$/;"	s	object:files.associations
invite	srcs/server.cpp	/^bool	Server::invite(int client, std::string message)$/;"	f	class:Server	typeref:typename:bool
iomanip	.vscode/settings.json	/^		"iomanip": "cpp",$/;"	s	object:files.associations
iosfwd	.vscode/settings.json	/^		"iosfwd": "cpp",$/;"	s	object:files.associations
iostream	.vscode/settings.json	/^		"iostream": "cpp",$/;"	s	object:files.associations
is_away	Includes/Client.hpp	/^		bool		is_away( void ) const { return m_away; }$/;"	f	class:Client	typeref:typename:bool
is_client_in	srcs/Channel.cpp	/^bool	Channel::is_client_in(std::string client) const$/;"	f	class:Channel	typeref:typename:bool
is_client_in_channel	srcs/server.cpp	/^bool	Server::is_client_in_channel(std::string channel, std::string client)$/;"	f	class:Server	typeref:typename:bool
is_me	Includes/Client.hpp	/^		static bool	is_me( Client* me, Client* other) { return (me->get_nick() == other->get_nick()); /;"	f	class:Client	typeref:typename:bool
is_me	Includes/Client.hpp	/^		static bool	is_me( Client* me, std::string other) { return (me->get_nick() == other); }$/;"	f	class:Client	typeref:typename:bool
is_op	srcs/Channel.cpp	/^bool	Channel::is_op(std::string client) const$/;"	f	class:Channel	typeref:typename:bool
istream	.vscode/settings.json	/^		"istream": "cpp",$/;"	s	object:files.associations
iterator	.vscode/settings.json	/^		"iterator": "cpp",$/;"	s	object:files.associations
join	srcs/server.cpp	/^bool	Server::join(int client, std::string channel)$/;"	f	class:Server	typeref:typename:bool
join_channel	srcs/Channel.cpp	/^void	Channel::join_channel(Client& client, std::string parameters)$/;"	f	class:Channel	typeref:typename:void
kick	srcs/server.cpp	/^bool	Server::kick(int client, std::string message)$/;"	f	class:Server	typeref:typename:bool
limits	.vscode/settings.json	/^		"limits": "cpp",$/;"	s	object:files.associations
m_addr	Includes/server.hpp	/^		struct sockaddr_in m_addr;$/;"	m	class:Server	typeref:struct:sockaddr_in
m_angry_input	Includes/cuocuo.hpp	/^		std::set<std::string> m_angry_input;$/;"	m	class:Coucou	typeref:typename:std::set<std::string>
m_angry_name	Includes/cuocuo.hpp	/^		std::string m_angry_name;$/;"	m	class:Coucou	typeref:typename:std::string
m_angry_words	Includes/cuocuo.hpp	/^		std::vector<std::string> m_angry_words;$/;"	m	class:Coucou	typeref:typename:std::vector<std::string>
m_away	Includes/Client.hpp	/^		bool		m_away;$/;"	m	class:Client	typeref:typename:bool
m_away_msg	Includes/Client.hpp	/^		std::string m_away_msg;$/;"	m	class:Client	typeref:typename:std::string
m_bans	Includes/Channel.hpp	/^		std::set<std::string>	m_bans;$/;"	m	class:Channel	typeref:typename:std::set<std::string>
m_base_respones	Includes/cuocuo.hpp	/^		std::vector<std::string> m_base_respones;$/;"	m	class:Coucou	typeref:typename:std::vector<std::string>
m_channels	Includes/server.hpp	/^		std::map<std::string, Channel*> m_channels;$/;"	m	class:Server	typeref:typename:std::map<std::string,Channel * >
m_clientAddr	Includes/Client.hpp	/^		struct sockaddr_in m_clientAddr;$/;"	m	class:Client	typeref:struct:sockaddr_in
m_clientSocket	Includes/Client.hpp	/^		int			m_clientSocket;$/;"	m	class:Client	typeref:typename:int
m_clients	Includes/Channel.hpp	/^		std::set<std::string> m_clients;$/;"	m	class:Channel	typeref:typename:std::set<std::string>
m_clients	Includes/server.hpp	/^		std::map<int, Client*>		m_clients;$/;"	m	class:Server	typeref:typename:std::map<int,Client * >
m_cmds	Includes/Client.hpp	/^		std::map<std::string, bool (Client::*)(std::string)> m_cmds;$/;"	m	class:Client	typeref:typename:std::map<std::string,bool (Client::*)(std::string)>
m_cmds	Includes/server.hpp	/^		std::map<std::string, bool (Server::*)(int, std::string)> m_cmds;$/;"	m	class:Server	typeref:typename:std::map<std::string,bool (Server::*)(int,std::string)>
m_commands	Includes/server.hpp	/^		std::set<std::string> m_commands;$/;"	m	class:Server	typeref:typename:std::set<std::string>
m_connected	Includes/Client.hpp	/^		bool		m_connected;$/;"	m	class:Client	typeref:typename:bool
m_coucou	Includes/server.hpp	/^		Coucou						m_coucou;$/;"	m	class:Server	typeref:typename:Coucou
m_date	Includes/server.hpp	/^		std::string					m_date;$/;"	m	class:Server	typeref:typename:std::string
m_happy_input	Includes/cuocuo.hpp	/^		std::set<std::string> m_happy_input;$/;"	m	class:Coucou	typeref:typename:std::set<std::string>
m_happy_name	Includes/cuocuo.hpp	/^		std::string m_happy_name;$/;"	m	class:Coucou	typeref:typename:std::string
m_happy_words	Includes/cuocuo.hpp	/^		std::vector<std::string> m_happy_words;$/;"	m	class:Coucou	typeref:typename:std::vector<std::string>
m_hash	Includes/server.hpp	/^		std::string					m_hash;$/;"	m	class:Server	typeref:typename:std::string
m_hostname	Includes/Client.hpp	/^		std::string m_hostname;$/;"	m	class:Client	typeref:typename:std::string
m_invites	Includes/Channel.hpp	/^		std::set<std::string>	m_invites;$/;"	m	class:Channel	typeref:typename:std::set<std::string>
m_key	Includes/Channel.hpp	/^		std::string 		m_key;$/;"	m	class:Channel	typeref:typename:std::string
m_limit	Includes/Channel.hpp	/^		int					m_limit;$/;"	m	class:Channel	typeref:typename:int
m_mode_funcs	Includes/Channel.hpp	/^		std::map<char, void (Channel::*)(Client&, std::string, bool)> m_mode_funcs;$/;"	m	class:Channel	typeref:typename:std::map<char,void (Channel::*)(Client &,std::string,bool)>
m_modes	Includes/Channel.hpp	/^		std::map<char, int> m_modes;$/;"	m	class:Channel	typeref:typename:std::map<char,int>
m_name	Includes/Channel.hpp	/^		std::string			m_name;$/;"	m	class:Channel	typeref:typename:std::string
m_name	Includes/cuocuo.hpp	/^		std::string m_name;$/;"	m	class:Coucou	typeref:typename:std::string
m_nick	Includes/Client.hpp	/^		std::string m_nick;$/;"	m	class:Client	typeref:typename:std::string
m_ops	Includes/Channel.hpp	/^		std::set<std::string>	m_ops;$/;"	m	class:Channel	typeref:typename:std::set<std::string>
m_port	Includes/server.hpp	/^		int			m_port;$/;"	m	class:Server	typeref:typename:int
m_realname	Includes/Client.hpp	/^		std::string m_realname;$/;"	m	class:Client	typeref:typename:std::string
m_reg_steps	Includes/Client.hpp	/^		int	m_reg_steps;$/;"	m	class:Client	typeref:typename:int
m_registered	Includes/Client.hpp	/^		bool		m_registered;$/;"	m	class:Client	typeref:typename:bool
m_relations	Includes/cuocuo.hpp	/^		std::map<std::string, relation> m_relations; \/\/ true = happy, false = angry$/;"	m	class:Coucou	typeref:typename:std::map<std::string,relation>
m_salt	Includes/server.hpp	/^		std::string					m_salt;$/;"	m	class:Server	typeref:typename:std::string
m_server	Includes/Channel.hpp	/^		Server				*m_server;$/;"	m	class:Channel	typeref:typename:Server *
m_servername	Includes/Client.hpp	/^		std::string m_servername;$/;"	m	class:Client	typeref:typename:std::string
m_socket	Includes/server.hpp	/^		int			m_socket;$/;"	m	class:Server	typeref:typename:int
m_topic	Includes/Channel.hpp	/^		std::string 		m_topic;$/;"	m	class:Channel	typeref:typename:std::string
m_user	Includes/Client.hpp	/^		std::string m_user;$/;"	m	class:Client	typeref:typename:std::string
main	client.cpp	/^int main() {$/;"	f	typeref:typename:int
main	srcs/main.cpp	/^int main(int ac, char **av)$/;"	f	typeref:typename:int
map	.vscode/settings.json	/^		"map": "cpp",$/;"	s	object:files.associations
memory	.vscode/settings.json	/^		"memory": "cpp",$/;"	s	object:files.associations
memory_resource	.vscode/settings.json	/^		"memory_resource": "cpp",$/;"	s	object:files.associations
mode	srcs/server.cpp	/^bool	Server::mode(int client, std::string message)$/;"	f	class:Server	typeref:typename:bool
modify_ban	srcs/Channel.cpp	/^void	Channel::modify_ban(Client &client, std::string parameters, bool what)$/;"	f	class:Channel	typeref:typename:void
modify_invite	srcs/Channel.cpp	/^void	Channel::modify_invite(Client &client, std::string parameters, bool what)$/;"	f	class:Channel	typeref:typename:void
modify_key_mode	srcs/Channel.cpp	/^void	Channel::modify_key_mode(Client &client, std::string parameters, bool what)$/;"	f	class:Channel	typeref:typename:void
modify_limit	srcs/Channel.cpp	/^void	Channel::modify_limit(Client &client, std::string parameters, bool what)$/;"	f	class:Channel	typeref:typename:void
modify_mode	srcs/Channel.cpp	/^bool	Channel::modify_mode(std::vector<std::string> command, Client &client)$/;"	f	class:Channel	typeref:typename:bool
modify_op	srcs/Channel.cpp	/^void	Channel::modify_op(Client &client, std::string parameters, bool what)$/;"	f	class:Channel	typeref:typename:void
modify_topic_mode	srcs/Channel.cpp	/^void	Channel::modify_topic_mode(Client &client, std::string parameters, bool what)$/;"	f	class:Channel	typeref:typename:void
name	.vscode/launch.json	/^		"name": "(gdb) Launch",$/;"	s	object:configurations.0
names	srcs/server.cpp	/^bool	Server::names(int client, std::string params)$/;"	f	class:Server	typeref:typename:bool
new	.vscode/settings.json	/^		"new": "cpp",$/;"	s	object:files.associations
nick	srcs/Client.cpp	/^bool Client::nick(std::string new_nick)$/;"	f	class:Client	typeref:typename:bool
numeric	.vscode/settings.json	/^		"numeric": "cpp",$/;"	s	object:files.associations
operator !=	Includes/Client.hpp	/^		bool	operator!=(Client const &src) const { return !(*this == src); }$/;"	f	class:Client	typeref:typename:bool
operator <	Includes/Client.hpp	/^		bool	operator<(Client const &src) const { return (m_clientSocket < src.get_clientSocket()); }$/;"	f	class:Client	typeref:typename:bool
operator <<	Includes/Channel.hpp	/^inline std::ostream &operator<<(std::ostream &o, std::map<char, void (Channel::*)(Client&, std::/;"	f	typeref:typename:std::ostream &
operator <<	Includes/Channel.hpp	/^inline std::ostream &operator<<(std::ostream &o, std::map<std::string, Channel*> const &v) {$/;"	f	typeref:typename:std::ostream &
operator <<	Includes/Client.hpp	/^inline std::ostream &operator<<(std::ostream &o, std::map<std::string, Client*> const &v) {$/;"	f	typeref:typename:std::ostream &
operator <<	Includes/Client.hpp	/^inline std::ostream &operator<<(std::ostream &o, std::set<std::string> const &v) {$/;"	f	typeref:typename:std::ostream &
operator <<	Includes/Client.hpp	/^inline std::ostream &operator<<(std::ostream &out, std::vector<Client*> clients) {$/;"	f	typeref:typename:std::ostream &
operator <<	Includes/main.hpp	/^inline std::ostream &operator<<(std::ostream &o, std::vector<std::string> const &v)$/;"	f	typeref:typename:std::ostream &
operator <<	srcs/Client.cpp	/^std::ostream &operator<<(std::ostream &out, Client const &src)$/;"	f	typeref:typename:std::ostream &
operator =	srcs/Channel.cpp	/^Channel& Channel::operator=(Channel const &src)$/;"	f	class:Channel	typeref:typename:Channel &
operator =	srcs/Client.cpp	/^Client& Client::operator=(Client const &src)$/;"	f	class:Client	typeref:typename:Client &
operator ==	Includes/Client.hpp	/^		bool	operator==(Client const &src) const { return (m_clientSocket == src.get_clientSocket()); /;"	f	class:Client	typeref:typename:bool
operator ==	Includes/Client.hpp	/^		bool	operator==(Client* const src) const { return (m_nick == src->get_nick()); }$/;"	f	class:Client	typeref:typename:bool
operator ==	Includes/Client.hpp	/^		bool	operator==(std::string const &src) const { return (m_nick == src); }$/;"	f	class:Client	typeref:typename:bool
operator ==	Includes/main.hpp	/^inline bool operator==(const struct pollfd& pfd, int fd)$/;"	f	typeref:typename:bool
operator >	Includes/Client.hpp	/^		bool	operator>(Client const &src) const { return (m_clientSocket > src.get_clientSocket()); }$/;"	f	class:Client	typeref:typename:bool
optional	.vscode/settings.json	/^		"optional": "cpp",$/;"	s	object:files.associations
ostream	.vscode/settings.json	/^		"ostream": "cpp",$/;"	s	object:files.associations
parse_cmds	srcs/Client.cpp	/^bool	Client::parse_cmds(std::string cmd)$/;"	f	class:Client	typeref:typename:bool
parse_cmds	srcs/server.cpp	/^void	Server::parse_cmds(int client, std::string cmd)$/;"	f	class:Server	typeref:typename:void
parse_message	bonus/coucou.cpp	/^void	Coucou::parse_message(Client& client, std::string message)$/;"	f	class:Coucou	typeref:typename:void
part	srcs/server.cpp	/^bool	Server::part(int client, std::string channels)$/;"	f	class:Server	typeref:typename:bool
pass	srcs/server.cpp	/^bool	Server::pass(int client, std::string message)$/;"	f	class:Server	typeref:typename:bool
ping	srcs/server.cpp	/^bool Server::ping(int client, std::string message)$/;"	f	class:Server	typeref:typename:bool
play	Makefile	/^play: re$/;"	t
printLogo	utils/string_utils.cpp	/^void printLogo(std::string ip, int port) {$/;"	f	typeref:typename:void
print_relations	bonus/coucou.cpp	/^void	Coucou::print_relations(Client& client)$/;"	f	class:Coucou	typeref:typename:void
privmsg	srcs/server.cpp	/^bool	Server::privmsg(int client, std::string message)$/;"	f	class:Server	typeref:typename:bool
program	.vscode/launch.json	/^		"program": "${workspaceFolder}\/ircserv",$/;"	s	object:configurations.0
quit	srcs/server.cpp	/^bool	Server::quit(int client, std::string message)$/;"	f	class:Server	typeref:typename:bool
random	.vscode/settings.json	/^		"random": "cpp",$/;"	s	object:files.associations
ranges	.vscode/settings.json	/^		"ranges": "cpp",$/;"	s	object:files.associations
re	Makefile	/^re: fclean all$/;"	t
read_from_client	srcs/server.cpp	/^void Server::read_from_client(int client)$/;"	f	class:Server	typeref:typename:void
register_client	srcs/server.cpp	/^void Server::register_client(int client)$/;"	f	class:Server	typeref:typename:void
relation	Includes/cuocuo.hpp	/^}		relation;$/;"	t	typeref:enum:e_relation
remove_client	srcs/Channel.cpp	/^void	Channel::remove_client(std::string client)$/;"	f	class:Channel	typeref:typename:void
request	.vscode/launch.json	/^		"request": "launch",$/;"	s	object:configurations.0
scale_down	utils/string_utils.cpp	/^std::vector<std::string> scale_down(std::vector<std::string> art, int terminalWidth, int termina/;"	f	typeref:typename:std::vector<std::string>
send_bans	srcs/Channel.cpp	/^void	Channel::send_bans(Client &client)$/;"	f	class:Channel	typeref:typename:void
send_message	bonus/coucou.cpp	/^void	Coucou::send_message(Client& client, std::string message)$/;"	f	class:Coucou	typeref:typename:void
send_message	srcs/Client.cpp	/^bool Client::send_message(Client receiver, std::string message)$/;"	f	class:Client	typeref:typename:bool
send_message	srcs/Client.cpp	/^bool Client::send_message(std::string message)$/;"	f	class:Client	typeref:typename:bool
send_modes	srcs/Channel.cpp	/^void	Channel::send_modes(Client &client)$/;"	f	class:Channel	typeref:typename:void
send_msg_to_channel	srcs/server.cpp	/^bool	Server::send_msg_to_channel(int client, std::string channel, std::string msg)$/;"	f	class:Server	typeref:typename:bool
send_topic	srcs/Channel.cpp	/^bool	Channel::send_topic(Client &client)$/;"	f	class:Channel	typeref:typename:bool
server_fd	Includes/server.hpp	/^		struct pollfd 				server_fd;$/;"	m	class:Server	typeref:struct:pollfd
set	.vscode/settings.json	/^		"set": "cpp",$/;"	s	object:files.associations
set_bans	Includes/Channel.hpp	/^		void	set_bans(std::set<std::string> bans) { m_bans = bans; }$/;"	f	class:Channel	typeref:typename:void
set_connected	Includes/Client.hpp	/^		void		set_connected(bool conn) { m_connected = conn; }$/;"	f	class:Client	typeref:typename:void
set_hostname	Includes/Client.hpp	/^		void		set_hostname(std::string hostname) { m_hostname = hostname; }$/;"	f	class:Client	typeref:typename:void
set_key	Includes/Channel.hpp	/^		void	set_key(std::string key) { m_key = key; }$/;"	f	class:Channel	typeref:typename:void
set_limit	Includes/Channel.hpp	/^		void	set_limit(int limit) { m_limit = limit; }$/;"	f	class:Channel	typeref:typename:void
set_modes	Includes/Channel.hpp	/^		void	set_modes(std::map<char, int> modes) { m_modes = modes; }$/;"	f	class:Channel	typeref:typename:void
set_name	Includes/Channel.hpp	/^		void	set_name(std::string name) { m_name = name; }$/;"	f	class:Channel	typeref:typename:void
set_nick	Includes/Client.hpp	/^		void		set_nick(std::string nick) { m_nick = nick; }$/;"	f	class:Client	typeref:typename:void
set_realname	Includes/Client.hpp	/^		void		set_realname(std::string realname) { m_realname = realname; }$/;"	f	class:Client	typeref:typename:void
set_reg	Includes/Client.hpp	/^		void		set_reg(int step) { m_reg_steps = step; }$/;"	f	class:Client	typeref:typename:void
set_registered	Includes/Client.hpp	/^		void		set_registered(bool reg) { m_registered = reg; }$/;"	f	class:Client	typeref:typename:void
set_servername	Includes/Client.hpp	/^		void		set_servername(std::string servername) { m_servername = servername; }$/;"	f	class:Client	typeref:typename:void
set_topic	Includes/Channel.hpp	/^		void	set_topic(std::string topic) { m_topic = topic; }$/;"	f	class:Channel	typeref:typename:void
set_user	Includes/Client.hpp	/^		void		set_user(std::string user) { m_user = user; }$/;"	f	class:Client	typeref:typename:void
setupCommands	.vscode/launch.json	/^		"setupCommands": [$/;"	a	object:configurations.0
split	utils/string_utils.cpp	/^std::vector<std::string> split(std::string str, std::string token)$/;"	f	typeref:typename:std::vector<std::string>
sstream	.vscode/settings.json	/^		"sstream": "cpp",$/;"	s	object:files.associations
stdexcept	.vscode/settings.json	/^		"stdexcept": "cpp",$/;"	s	object:files.associations
stopAtEntry	.vscode/launch.json	/^		"stopAtEntry": false,$/;"	b	object:configurations.0
streambuf	.vscode/settings.json	/^		"streambuf": "cpp",$/;"	s	object:files.associations
string	.vscode/settings.json	/^		"string": "cpp",$/;"	s	object:files.associations
string_view	.vscode/settings.json	/^		"string_view": "cpp",$/;"	s	object:files.associations
system_error	.vscode/settings.json	/^		"system_error": "cpp",$/;"	s	object:files.associations
text	.vscode/launch.json	/^				"text": "-enable-pretty-printing",$/;"	s	object:configurations.0.setupCommands.0
text	.vscode/launch.json	/^				"text": "-gdb-set disassembly-flavor intel",$/;"	s	object:configurations.0.setupCommands.1
topic	srcs/server.cpp	/^bool	Server::topic(int client, std::string params)$/;"	f	class:Server	typeref:typename:bool
topuc	srcs/Channel.cpp	/^void	Channel::topuc(Client &client, std::string parameters)$/;"	f	class:Channel	typeref:typename:void
trimString	utils/string_utils.cpp	/^std::string trimString(std::string nick)$/;"	f	typeref:typename:std::string
tuple	.vscode/settings.json	/^		"tuple": "cpp",$/;"	s	object:files.associations
type	.vscode/launch.json	/^		"type": "cppdbg",$/;"	s	object:configurations.0
type_traits	.vscode/settings.json	/^		"type_traits": "cpp",$/;"	s	object:files.associations
typeinfo	.vscode/settings.json	/^		"typeinfo": "cpp",$/;"	s	object:files.associations
unordered_map	.vscode/settings.json	/^		"unordered_map": "cpp",$/;"	s	object:files.associations
user	srcs/server.cpp	/^bool	Server::user(int client, std::string message)$/;"	f	class:Server	typeref:typename:bool
userhost	srcs/server.cpp	/^bool	Server::userhost(int client, std::string message)$/;"	f	class:Server	typeref:typename:bool
utility	.vscode/settings.json	/^		"utility": "cpp",$/;"	s	object:files.associations
val	Makefile	/^val : re$/;"	t
vector	.vscode/settings.json	/^		"vector": "cpp",$/;"	s	object:files.associations
verify_password	srcs/Hashing.cpp	/^bool verify_password(const std::string& entered_password, const std::string& stored_hash, const /;"	f	typeref:typename:bool
what	Includes/server.hpp	/^			virtual const char *what() const throw()$/;"	f	class:Server::ClientException	typeref:typename:const char *
what	Includes/server.hpp	/^			virtual const char *what() const throw()$/;"	f	class:Server::PollException	typeref:typename:const char *
what	Includes/server.hpp	/^			virtual const char *what() const throw()$/;"	f	class:Server::clientSocketException	typeref:typename:const char *
who	srcs/server.cpp	/^bool	Server::who(int client, std::string message)$/;"	f	class:Server	typeref:typename:bool
write_to_client	srcs/server.cpp	/^void Server::write_to_client(int client, std::string msg)$/;"	f	class:Server	typeref:typename:void
~Channel	srcs/Channel.cpp	/^Channel::~Channel()$/;"	f	class:Channel
~Client	srcs/Client.cpp	/^Client::~Client()$/;"	f	class:Client
~Coucou	bonus/coucou.cpp	/^Coucou::~Coucou()$/;"	f	class:Coucou
~Server	srcs/server.cpp	/^Server::~Server()$/;"	f	class:Server
